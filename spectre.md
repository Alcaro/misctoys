List of CPU bugs discovered recently (i.e. Spectre and later)

Most or all these only allow speculatively accessing inappropriate data, and rely on some other mechanism to leak it to the real code. They cannot modify data, unless they can leak (e.g.) the root password and utilize that.

One (the only?) way to do that is to speculatively access different addresses depending on the stolen data, bringing it into the cache; then, when speculation aborts, measure timing to access those addresses, revealing what value the speculation touched.

| Marketing name | Public disclosure | Description | Link | Migitated on Linux? |
| ---------- | ---------- | ---------- | ---------- | ---------- |
| Spectre 1 - Bounds Check Bypass | 2018-01-03<br>CVE-2017-5753 | Constructions like `if (idx < limit) return foo[bar[idx]]` can, if the branch is mispredicted, leak the address of `foo[bar[too_big_index]]`, i.e. the value of `bar[too_big_index]` | https://meltdownattack.com/ | Partial migitations exist, but work is still ongoing |
| Spectre 2 - Branch Target Injection | 2018-01-03<br>CVE-2017-5715 | Indirect jumps (such as virtual function calls) can be manipulated into being mispredicted, allowing speculative execution of arbitrary code, allowing simulation of devices like the above | https://meltdownattack.com/ | Yes, retpoline |
| Meltdown (Spectre 3) - Rogue Data Cache Load | 2018-01-03<br>CVE-2017-5754 | Page access prorections are not enforced during speculative execution, allowing leaking the entire kernel memory | https://meltdownattack.com/ | Yes, KPTI |
| BranchScope | 2018-03-27<br>CVE-2018-9056 | Allows leaking branch predictor state, i.e. branches on secret data; may also be able to break ASLR | http://www.cs.ucr.edu/~nael/pubs/asplos18.pdf | No, likely unneeded (branches on secret data have always been a bad idea) |
| Rogue System Register Read (Spectre 3a) | 2018-05-23<br>CVE-2018-3640 | Various control registers are speculatively accessible. Yes, it's that simple. (Though this seems to leak little if any useful information, the only useful data I can identify is a few physical addresses.) | https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00115.html | Yes, microcode |
| Speculative Store Bypass (Spectre 4) | 2018-05-23<br>CVE-2018-3639 | `int* x = &secret; int** px = &x; *px = &public; attacker(*x);` can speculatively access 'secret' if \*px is predicted to not alias x; similarly, `int bound = 0xFFFF; int* pbound = &bound; *pbound = 0x20; if (index < bound)` can speculatively compare to the old value | https://software.intel.com/security-software-guidance/api-app/sites/default/files/336996-Speculative-Execution-Side-Channel-Mitigations.pdf | Yes, microcode |
| Lazy FP State Restore (Spectre-NG) | 2018-06-13<br>CVE-2018-3665 | Floating-point state is not saved and restored by the kernel on all task switches, but only if floating-point instructions are actually used by the new process. Natually, this means other processes' floating-point registers are available during speculation. | https://blog.cyberus-technology.de/posts/2018-06-06-intel-lazyfp-vulnerability.html | Yes, state always saved and restored (patched in 2016, but nobody noticed it fixed a vulnerability) |
| TLBleed | 2018-06-22<br>no CVE | Floating-point state is not saved and restored by the kernel on all task switches, but only if floating-point instructions are actually used by the new process. Natually, this means other processes' floating-point registers are available during speculation. | https://www.theregister.co.uk/2018/06/22/intel_tlbleed_key_data_leak/ | No, likely unneeded (secret-dependent address calculations have always been a bad idea) |
| Bounds Check Bypass Store (Spectre 1.1) | 2018-07-10<br>CVE-2018-3693 | Speculative writes can affect future speculative execution, allowing speculative execution of arbitrary code like Spectre 2 | https://people.csail.mit.edu/vlk/spectre11.pdf | Same as Spectre 1? |
| Read-only protection bypass (Spectre 1.2) | 2018-07-10<br>can't find a CVE | Speculative writes to read-only memory succeed (though I can't see what that'd let you do that you couldn't already) | https://people.csail.mit.edu/vlk/spectre11.pdf | Same as Spectre 1? |
| SpectreRSB | 2018-07-24<br>can't find a CVE | The CPU remembers the 16 last CALL instructions, and speculatively predicts execution will continue there upon RET; not unexpectedly, you get Spectre 2 if the buffer runs out | https://arxiv.org/pdf/1807.07940.pdf | Work is ongoing, not sure how much is merged |
| NetSpectre | 2018-07-27<br>can't find a CVE | Seems to just be Spectre 1 across the network, except that AVX2 part, I can't quite figure it out | https://lwn.net/Articles/761100/ | Same as Spectre 1? |
| Foreshadow (Foreshadow-SGX) | 2018-08-18<br>CVE-2018-3615 | If a page belonging to an SGX enclave is marked not readable, but data from it is present in the L1 cache, the plaintext can speculatively be read | https://foreshadowattack.eu/ | Yes, microcode |
| L1 Terminal Fault (Foreshadow NG, Foreshadow-OS) | 2018-08-18<br>CVE-2018-3620 | Page table entries marked as invalid are speculatively treated as valid, allowing disclosure of the accidentally pointed-to page, if the data is present in the L1 data cache | https://foreshadowattack.eu/ (the Foreshadow-NG paper is quite easy to read) | Yes, microcode |
| L1 Terminal Fault (Foreshadow NG, Foreshadow-VMM) | 2018-08-18<br>CVE-2018-3646 | Guest-physical addresses are not properly translated to host-physical addresses if the page is not present (which a malicious VM can easily arrange); combined with the above, it allows speculative access to the host's entire L1 data cache | https://foreshadowattack.eu/ | Yes, microcode |
| (Turning Page Tables?) | (2018-08-08?) | something with page tables and read-only pages shared between privilege levels; full details seem only available in video form, which have too bad information-per-second and seekability to be useful | https://blog.ensilo.com/bypassing-kernel-mitigations | ? |
