List of CPU bugs discovered recently (Spectre/Meltdown and later)

Most or all these only allow speculatively accessing inappropriate data, and rely on some other mechanism to leak it to the real code. They cannot modify data, except possibly indirectly (for example by leaking and using the root password, or by using them to bypass ASLR and combining that with something else).

One (the only?) way to do that is to speculatively access different addresses depending on the stolen data, bringing it into the cache; then, when speculation aborts, measure timing to access those addresses, revealing what value the speculation touched.

Additionally, depending on how you count, some of them may be trivial variants of each other with identical migitations, not worth considering separate. I've split everything with a marketing name, but noted (my understanding of) how they relate to each other.

| Marketing name | Public disclosure | Description | Link | Migitated on Linux? |
| ---------- | ---------- | ---------- | ---------- | ---------- |
| Spectre 1 - Bounds Check Bypass | 2018-01-03<br>CVE-2017-5753 | Constructions like `if (idx < limit) return foo[bar[idx]]` can, if the branch is mispredicted, leak the address of `foo[bar[too_big_index]]`, i.e. the value of `bar[too_big_index]` | https://meltdownattack.com/ | Partial migitations exist, but work is still ongoing |
| Spectre 2 - Branch Target Injection | 2018-01-03<br>CVE-2017-5715 | Indirect jumps (such as virtual function calls) can be manipulated into being mispredicted, allowing speculative execution of arbitrary code, allowing simulation of devices like the above | https://meltdownattack.com/ | Yes in userspace, retpoline; work ongoing in kernel |
| Meltdown (Spectre 3) - Rogue Data Cache Load | 2018-01-03<br>CVE-2017-5754 | Page access prorections are not enforced during speculative execution, allowing leaking the entire kernel memory | https://meltdownattack.com/ | Yes, KPTI |
| BranchScope | 2018-03-27<br>CVE-2018-9056 | Allows leaking branch predictor state, i.e. branches on secret data; may also be able to break ASLR | http://www.cs.ucr.edu/~nael/pubs/asplos18.pdf | Yes (even prior to disclosure), secret-dependent branches have always been a timing leak |
| Rogue System Register Read (Spectre 3a) | 2018-05-23<br>CVE-2018-3640 | Various control registers are speculatively readable. Yes, it's that simple. (Though this seems to leak little if any useful information, the only useful data I can identify is a few physical addresses.) | https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00115.html | Yes, microcode |
| Speculative Store Bypass (Spectre 4) | 2018-05-23<br>CVE-2018-3639 | `int* x = &secret; int** px = &x; *px = &public; attacker(*x);` can speculatively access 'secret' if \*px is predicted to not alias x; similarly, `int bound = 0xFFFF; int* pbound = &bound; *pbound = 0x20; if (index < bound)` can speculatively compare to the old value | https://software.intel.com/security-software-guidance/api-app/sites/default/files/336996-Speculative-Execution-Side-Channel-Mitigations.pdf | Yes, microcode |
| Lazy FP State Restore (Spectre-NG) | 2018-06-13<br>CVE-2018-3665 | Floating-point state is not saved and restored by the kernel on all task switches, but only if floating-point instructions are actually used by the new process. Natually, this means other processes' floating-point registers are available during speculation. | https://blog.cyberus-technology.de/posts/2018-06-06-intel-lazyfp-vulnerability.html | Yes, the correct state is now always saved and restored (patched in 2016, but nobody noticed it fixed a vulnerability) |
| TLBleed | 2018-06-22<br>no CVE | Hyperthreading can be used to leak TLB contents (addresses being operated on) from the sibling hyperthread | https://www.theregister.co.uk/2018/06/22/intel_tlbleed_key_data_leak/ | Yes (even prior to disclosure), secret-dependent branches have always been a timing leak |
| Bounds Check Bypass Store (Spectre 1.1) | 2018-07-10<br>CVE-2018-3693 | Speculative writes can affect future speculative execution, allowing speculative execution of arbitrary return addresses, like Spectre 2 | https://people.csail.mit.edu/vlk/spectre11.pdf | Same as Spectre 1? |
| Read-only protection bypass (Spectre 1.2) | 2018-07-10<br>can't find a CVE | Speculative writes to read-only memory succeed (though I can't see what that'd let you do that you couldn't already) | https://people.csail.mit.edu/vlk/spectre11.pdf | Same as Spectre 1? |
| SpectreRSB | 2018-07-24<br>can't find a CVE | The CPU remembers the 16 last CALL instructions, and speculatively predicts execution will continue there upon RET; not unexpectedly, you get Spectre 2 if the buffer runs out | https://arxiv.org/pdf/1807.07940.pdf | Work is ongoing, not sure how much is merged |
| NetSpectre | 2018-07-27<br>can't find a CVE | Seems to just be Spectre 1 across the network, except that AVX2 part which I can't quite figure out | https://lwn.net/Articles/761100/ | Same as Spectre 1? |
| Rosenbridge | 2018-08-09<br>can't find a CVE | VIA C3 processors contain an unprivileged instruction to execute a hidden internal high-privileged RISC instruction set (either a backdoor or a debug tool, depending on who you ask); it's supposed to be disabled by default, but sometimes it's left enabled | https://github.com/xoreaxeaxeax/rosenbridge | Configure them properly, or avoid those CPUs (they're rare) |
| Foreshadow (Foreshadow-SGX) | 2018-08-18<br>CVE-2018-3615 | If a page belonging to an SGX enclave is marked not readable, but data from it is present in the L1 cache, the plaintext can speculatively be read | https://foreshadowattack.eu/ | Yes, microcode |
| L1 Terminal Fault (Foreshadow NG, Foreshadow-OS) | 2018-08-18<br>CVE-2018-3620 | Page table entries marked as invalid are speculatively treated as valid, allowing disclosure of the accidentally pointed-to page, if the data is present in the L1 data cache | https://foreshadowattack.eu/ (the Foreshadow-NG paper is quite easy to read) | Yes, microcode |
| L1 Terminal Fault (Foreshadow NG, Foreshadow-VMM) | 2018-08-18<br>CVE-2018-3646 | Guest-physical addresses are not properly translated to host-physical addresses if the page is not present (which a malicious VM can easily arrange); combined with the above, it allows speculative access to the host's entire L1 data cache | https://foreshadowattack.eu/ | Yes, microcode |
| ~~Turning Page Tables~~ | ~~2018-08-08?~~ | ~~something with page tables and read-only pages shared between privilege levels; full details seem only available in video form, which have too bad information-per-second and seekability to be useful~~ | ~~https://blog.ensilo.com/bypassing-kernel-mitigations~~ | considering the lack of outside coverage, and the lack of details, this is most likely a non-exploit |
